DT.http=(()=>{const HttpError=class extends Error{constructor(response,request,options){const code=response.status||response.status===0?response.status:'';const title=response.statusText??'';const status=`${code} ${title}`.trim();const reason=status?`status code ${status}`:'an unknown error';super(`Request failed with ${reason}`);this.name='DT.http.HttpError';this.response=response;this.request=request;this.options=options}};const HttpTimeoutError=class extends Error{constructor(request){super('Request timed out');this.name='DT.http.HttpTimeoutError';this.request=request}};const deepMerge=(...sources)=>{let returnValue={};let headers={};for(const source of sources){if(Array.isArray(source)){if(!Array.isArray(returnValue)){returnValue=[]}
returnValue=[...returnValue,...source]}else if(DT.isObject(source)){for(let[key,value]of Object.entries(source)){if(DT.isObject(value)&&key in returnValue){value=deepMerge(returnValue[key],value)}
returnValue={...returnValue,[key]:value}}
if(DT.isObject(source.headers)){headers=mergeHeaders(headers,source.headers);returnValue.headers=headers}}}
return returnValue};const mergeOptions=(...sources)=>{for(const source of sources){if((!DT.isObject(source)||Array.isArray(source))&&typeof source!=='undefined'){throw new TypeError('The `options` argument must be an object')}}
return deepMerge({},...sources)};const mergeHeaders=(source1={},source2={})=>{const result=new Headers(source1);const isHeadersInstance=source2 instanceof Headers;const source=new Headers(source2);for(const[key,value]of source.entries()){if((isHeadersInstance&&value==='undefined')||value===undefined){result.delete(key)}else{result.set(key,value)}}
return result};const requestMethods=['GET','POST','PUT','PATCH','HEAD','DELETE'];const responseTypes={json:'application/json',text:'text/*',formData:'multipart/form-data',arrayBuffer:'*/*',blob:'*/*',};const isQueryMethod=(method)=>['GET','HEAD'].includes(method);const params={bracketPattern:/\[\]$/,buildParamForQueryString({prefix,obj,add}){if(Array.isArray(obj)){obj.forEach((key,val)=>{if(this.bracketPattern.test(prefix)){add(prefix,key)}else{this.buildParamForQueryString({prefix:prefix+'['+(typeof key==='object'&&key!=null?val:'')+']',obj:key,add,})}});return}
if(DT.toType(obj)==='object'){for(let name in obj){this.buildParamForQueryString({prefix:prefix+'['+name+']',obj:obj[name],add,})}
return}
add(prefix,obj)},serializeQueryString(params){if(DT.isNullish(params))return'';const queryString=[];const add=(key,value)=>{value=typeof value==='function'?value():value;queryString.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`)};if(Array.isArray(params)){params.forEach((param)=>{add(param.name,param.value)})}else{for(const prefix in params){this.buildParamForQueryString({prefix,obj:params[prefix],add,})}}
return queryString.join('&')},serializeFormData(formData){return new URLSearchParams(formData)},serializeJson(params){return JSON.stringify(params)},serialize({method,params,contentType}){if(DT.isNullish(params))return'';if(typeof params==='string'||params instanceof URLSearchParams)return params;if(isQueryMethod(method)){if(params instanceof FormData){return this.serializeFormData(params)}
return this.serializeQueryString(params)}
if(contentType==='application/json'){return this.serializeJson(params)}
if(contentType==='multipart/form-data'){if(params instanceof FormData){return params}
return this.serializeFormData(params)}
if(contentType.startsWith('application/x-www-form-urlencoded')){return this.serializeQueryString(params)}
return params},};const nonce=()=>Date.now();const getContentType=(options)=>{if(options.requestDataType==='json'||options.parseJson){return'application/json'}
if(options.data instanceof FormData)return'multipart/form-data';return'application/x-www-form-urlencoded'};const decorateResponse=(response,options)=>{if(options.parseJson){response.json=async()=>options.parseJson(await response.text())}
return response};const maxSafeTimeout=2_147_483_647;const addAntiCsrfToken=(options)=>{options.data??(options.data={});if(options.data instanceof FormData||options.data instanceof URLSearchParams){options.data.set('securitycheck',DT.securitycheck);return}
options.data.securitycheck=DT.securitycheck};const createRequestData=(requestUrl,defaultOptions,requestOptions={})=>{const options=mergeOptions(defaultOptions,{credentials:requestOptions?.credentials??'same-origin',...requestOptions,hooks:deepMerge({beforeRequest:[],beforeError:[],afterResponse:[],},requestOptions?.hooks),});options.method=options.method.toUpperCase();if(!requestMethods.includes(options.method)){throw new Error(`Invalid request method: ${options.method}`)}
if(options.timeout>maxSafeTimeout){throw new Error(`\`timeout\` value is too large. Maximum safe value is ${maxSafeTimeout}`)}
if(isQueryMethod(options.method)&&options.onUploadProgress){throw new Error(`Upload progress can't be used with request method "${options.method}"`)}
let contentType;const url=requestUrl instanceof URL?requestUrl:new URL(requestUrl,options.baseUrl);if(isQueryMethod(options.method)){options.headers.delete('Content-Type')}else{if(DT.isNullish(options.headers.get('Content-Type'))){contentType=getContentType(options);if(contentType!=='multipart/form-data'){options.headers.set('Content-Type',contentType)}}
if(DT.isDtUrl(url.toString())&&DT.isNullish(options.data?.securitycheck)){addAntiCsrfToken(options)}}
if(!DT.isNullish(options.responseType)&&DT.isNullish(options.headers.get('Accept'))){options.headers.set('Accept',responseTypes[options.responseType])}
const serializedData=params.serialize({method:options.method,params:options.data,contentType:contentType,});if(serializedData){if(isQueryMethod(options.method)){url.search=serializedData.toString()}else{options.body=serializedData}}
if(isQueryMethod(options.method)&&options.noCacheWithParam){url.searchParams.set('_',nonce())}
return{options,url,}};const executeXhr=async({url,options})=>{return new Promise(async(resolve,reject)=>{options.headers.set('X-Requested-With','XMLHttpRequest');const xhr=new XMLHttpRequest();let timeoutId=null;xhr.responseType='blob';xhr.upload.onprogress=options.onUploadProgress;if(options.signal){options.signal.addEventListener('abort',()=>{xhr.abort()})}
xhr.onload=async()=>{clearTimeout(timeoutId);const headers={};const rawHeaders=xhr.getAllResponseHeaders().trim().split('\n');rawHeaders.forEach((header)=>{const split=header.trim().split(':');const key=split.shift().trim();const value=split.join(':').trim();headers[key]=value});const response=new Response(xhr.response,{status:xhr.status,statusText:xhr.statusText,headers,});Object.defineProperty(response,'url',{value:url.toString()});for(const hook of options.hooks.afterResponse){const modifiedResponse=await hook(options,decorateResponse(response.clone(),options));if(modifiedResponse instanceof Response){response=modifiedResponse}}
decorateResponse(response,options);if(!response.ok&&options.throwHttpErrors){let error=new DT.http.HttpError(response,request,options);for(const hook of options.hooks.beforeError){error=await hook(error)}
reject(error);return}
resolve(response)};xhr.onerror=()=>{reject(new Error('Network request failed'))};xhr.ontimeout=()=>{reject(new Error('Network request failed'))};for(const hook of options.hooks.beforeRequest){const result=await hook(url,options);if(result instanceof Response){resolve(result);return}}
xhr.open(options.method,url.toString(),!0);options.headers.forEach((value,name)=>{xhr.setRequestHeader(name,value)});xhr.send(options.body);if(options.timeout){timeoutId=setTimeout(()=>{try{xhr.abort()}catch(error){DT.log('error',`Failed to abort request: ${request.url} ${error}`)}
reject(new DT.http.HttpTimeoutError(xhr))},options.timeout)}})};const createRequestOptions=(options)=>{const omitOptions=['baseUrl','noCacheWithParam','parseJson','throwHttpErrors','responseType','hooks','onUploadProgress','data','requestDataType','timeout',];const requestOptions={};for(const key in options){if(!omitOptions.includes(key)&&options.hasOwnProperty(key)){requestOptions[key]=options[key]}}
return requestOptions};const createRequest=({url,options})=>{const requestOptions=createRequestOptions(options);const abortController=new AbortController();if(options.signal){options.signal.addEventListener('abort',()=>{abortController.abort(options.signal.reason)},{once:!0})}
requestOptions.signal=abortController.signal;const request=new Request(url,requestOptions);return{request,abortController}};const timeoutFetch=(request,options,abortController)=>{return new Promise((resolve,reject)=>{const timeoutId=setTimeout(()=>{try{if(abortController){abortController.abort()}}catch(error){DT.log('error',`Failed to abort request: ${request.url} ${error}`)}
reject(new DT.http.HttpTimeoutError(request))},options.timeout);fetch(request).then((response)=>{clearTimeout(timeoutId);resolve(response)}).catch((error)=>{clearTimeout(timeoutId);reject(error)})})};const _fetch=async(request,options,abortController)=>{for(const hook of options.hooks.beforeRequest){const result=await hook(request,options);if(result instanceof Request){request=result;break}
if(result instanceof Response){return result}}
if(!options.timeout)return fetch(request.clone());return timeoutFetch(request.clone(),options,abortController)};const executeFetch=async(request,options,abortController)=>{let response=await _fetch(request,options,abortController);for(const hook of options.hooks.afterResponse){const modifiedResponse=await hook(request,options,decorateResponse(response.clone(),options));if(modifiedResponse instanceof Response){response=modifiedResponse}}
decorateResponse(response,options);if(!response.ok&&options.throwHttpErrors){let error=new DT.http.HttpError(response,request,options);for(const hook of options.hooks.beforeError){error=await hook(error)}
throw error}
return response};const sendRequest=({requestUrl,defaultOptions,requestOptions={}})=>{const{url,options}=createRequestData(requestUrl,defaultOptions,requestOptions);let result;if(options.onUploadProgress){result=executeXhr({url,options})}else{const{request,abortController}=createRequest({url,options});result=executeFetch(request,options,abortController)}
for(const[type,_]of Object.entries(responseTypes)){result[type]=async()=>{const awaitedResult=await result;const response=awaitedResult.clone();if(type==='json'){if(response.status===204)return'';const arrayBuffer=await response.clone().arrayBuffer();const responseSize=arrayBuffer.byteLength;if(responseSize===0)return'';if(options.parseJson){return options.parseJson(await response.text())}}
return response[type]()}}
return result};const createInstance=({baseUrl,hooks={beforeRequest:[],afterResponse:[],beforeError:[],},noCacheWithParam=!1,throwHttpErrors=!1,responseType=null,headers={},timeout=!1,...restOptions}={})=>{const defaultOptions={...restOptions,headers,noCacheWithParam,responseType,throwHttpErrors,baseUrl:String(baseUrl??DT.ajaxBase),hooks,timeout,};return{get:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'GET'}),}),post:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'POST'}),}),put:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'PUT'}),}),patch:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'PATCH'}),}),delete:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'DELETE'}),}),head:(url,options={})=>sendRequest({requestUrl:url,defaultOptions,requestOptions:mergeOptions(options,{method:'HEAD'}),}),extend:(newDefaultOptions={})=>createInstance(mergeOptions(defaultOptions,newDefaultOptions)),}};const defaultClient=createInstance({baseUrl:DT.ajaxBase,});return{...defaultClient,create:createInstance,params,HttpError,HttpTimeoutError,}})()